use{std.Graphics};
use{std.PointerStack};
use{std.Arrays};
use{std.Base10};

asm{mapping};
asm{std.Chars};

PS_init(getHeap());

const KEY_SHIFT: byte = 54b;
const KEY_ALPHA: byte = 48b;
const KEY_LEFT: byte = 02b;
const KEY_RIGHT: byte = 03b;
const KEY_CLEAR: byte = 15b;
const KEY_MODE: byte = 55b;

const BLOCK_COUNT: byte = 7b;
const BACKGROUND_COLOR: byte = 74b;
const CONTOUR_COLOR: byte = 148b;
const TEXT_COLOR: byte = 0b;
const TICK_SPEED: int = 100i;
const FIELD_WIDTH: int = 10i;

var speed: int = 200i;

var _rotation: global byte = 0b;
var _block_color: global byte = 30b;
var _block_x: global int = 104i;
var _block_y: global int = 100i;
var _block_location: global pointer = &block_i;

var _level: global int = 0i;
var _score: global byte[] = newBase10(malloc(7b));
var _field: global byte[] = new byte[200i] at malloc(202b);
var _is_running: global bool = true;


fun setTile(X: int, Y: int, Value: byte){
    _field[(Y-100i)*FIELD_WIDTH+(X-100i)] = Value;
};

fun getTile(X: int, Y: int) -> byte{
    return _field[(Y-100i)*FIELD_WIDTH+(X-100i)];
};

fun clearLine(Y: int){
    var y: int = Y;
    while(y > 100i){
        var x: int = 100i;
        while(x < 110i){
            if(y == 101i){
                setTile(x, y-1i, 0b);
            }else{
                setTile(x, y, getTile(x, y-1i));
            };
            x = x + 1i;
        };
        y = y - 1i;
    };
};

fun checkClearLines(){
    var lines_cleared: byte = 0b;
    var y: int = 100i;
    while(y < 120i){
        var x: int = 100i;
        var is_full: bool = true;
        while(x < 110i){
            is_full = (getTile(x, y) != 0b) and is_full;
            x = x + 1i;
        };
        if(is_full){
            clearLine(y);
            lines_cleared = lines_cleared + 1b;
        };
        y = y + 1i;
    };
    if(lines_cleared == 1b){
        add(_score, (_level+1i) * 40i);
    }elif(lines_cleared == 2b){
        add(_score, (_level+1i) * 100i);
    }elif(lines_cleared == 3b){
        add(_score, (_level+1i) * 300i);
    }elif(lines_cleared == 4b){
        add(_score, (_level+1i) * 1200i);
    };
};

fun checkBlock(X: int, Y: int) -> bool{
    if((X > 109i) or (X < 100i) or (Y > 119i)){
        return true;
    };
    return getTile(X, Y) != 0b;
};

fun checkHitBox(X: int, Y: int, Block_location: pointer) -> bool{
    var y_offset: int = 0i;
    var i: int = 0i;
    while(y_offset < 4i){
        var x_offset: int = 0i;
        while(x_offset < 4i){
            if(Block_location + i -> bool){
                if(checkBlock(X + x_offset, Y + y_offset)){
                    return false;
                };
            };
            x_offset = x_offset + 1i;
            i = i + 1i;
        };
        y_offset = y_offset + 1i;
    };
    return true;
};

fun placeBlock(X: int, Y: int, Block_location: pointer, Block_color: byte) -> bool{
    var y_offset: int = 0i;
    var i: int = 0i;
    while(y_offset < 4i){
        var x_offset: int = 0i;
        while(x_offset < 4i){
            if(Block_location + i -> bool){
                if(Y+y_offset == 0i){
                    _is_running = false;
                    return true;
                };
                setTile(X+x_offset, Y+y_offset, Block_color);
            };
            x_offset = x_offset + 1i;
            i = i + 1i;
        };
        y_offset = y_offset + 1i;
    };
    checkClearLines();
};

fun selectBlock(){
    var block: int = merge(randomByte() % BLOCK_COUNT, 0b);
    _rotation = 0b;
    _block_location = &blocks + (block * 64i);
    _block_x = 104i;
    _block_y = 100i;
    _block_color = (&block_color + block) -> byte;
};

fun checkKeys(){
    var key: byte = scanKey();
    if(key != 0b){
        if(key == KEY_SHIFT){
            if(_rotation == 0b){
                if(checkHitBox(_block_x, _block_y, _block_location+48b)){
                    _rotation = 48b;
                };
            }else{
                if(checkHitBox(_block_x, _block_y, _block_location + _rotation - 16b)){
                    _rotation = _rotation - 16b;
                };
            };
        }elif(key == KEY_ALPHA){
            if(_rotation == 48b){
                if(checkHitBox(_block_x, _block_y, _block_location)){
                    _rotation = 0b;
                };
            }else{
                if(checkHitBox(_block_x, _block_y, _block_location + _rotation + 16b)){
                    _rotation = _rotation + 16b;
                };
            };
        }elif(key == KEY_LEFT){
            if(checkHitBox(_block_x - 1i, _block_y, _block_location+_rotation)){
                _block_x = _block_x - 1i;
            };
        }elif(key == KEY_RIGHT){
            if(checkHitBox(_block_x + 1i, _block_y, _block_location+_rotation)){
                _block_x = _block_x + 1i;
            };
        }elif(key == KEY_CLEAR){
            throw "";
        }elif(key == KEY_MODE){
            throw "";
        };
    };
};

use{TGraphics};
drawMode(false);
clearScreen(BACKGROUND_COLOR);
fillByteArray(_field, 0b);

while(_is_running){
    if(checkHitBox(_block_x, _block_y + 1i, _block_location+_rotation)){
        _block_y = _block_y + 1i;
    }else{
        if(placeBlock(_block_x, _block_y, _block_location+_rotation, _block_color)){
            break;
        };
        selectBlock();
    };

    checkKeys();

    var current_tick: int = 0i;
    while(current_tick < speed){
        graphics();

        current_tick = current_tick + TICK_SPEED;
        sleep(TICK_SPEED);
        checkKeys();
    };

};

pause();

